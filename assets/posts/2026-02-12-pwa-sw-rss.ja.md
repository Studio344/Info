# PWA・Service Worker・RSS — 静的サイトをアプリのように進化させる

ポートフォリオサイトに PWA（Progressive Web App）、Service Worker、RSS フィードを追加しました。フレームワークなしの Vanilla HTML/CSS/JS 構成でも、これらの機能は自前で実装できます。この記事では、各技術の実装方法と設計判断を解説します。

## Service Worker: Network-First キャッシュ戦略

### なぜ Service Worker か

Service Worker は、ブラウザとネットワークの間に位置するプロキシです。オフライン対応、キャッシュ制御、バックグラウンド同期などの機能を提供します。

### Network-First 戦略を選んだ理由

キャッシュ戦略にはいくつかのパターンがあります:

| 戦略 | 特徴 | 適用場面 |
|------|------|----------|
| Cache-First | キャッシュ優先、なければネットワーク | 変更の少ない静的リソース |
| Network-First | ネットワーク優先、失敗時キャッシュ | 頻繁に更新されるコンテンツ |
| Stale-While-Revalidate | キャッシュ即返却 + 裏でネットワーク更新 | バランス型 |

ブログ記事やプロジェクト情報が頻繁に更新されるため、**Network-First** を選択しました。

### 実装コード（sw.js）

```javascript
const CACHE_NAME = 'studio344-v1';
const OFFLINE_URL = '/404.html';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([OFFLINE_URL]);
    })
  );
  self.skipWaiting();
});

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // ネットワーク成功 → キャッシュに保存して返却
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
          return response;
        })
        .catch(() => {
          // ネットワーク失敗 → キャッシュから返却
          return caches.match(event.request)
            .then((cached) => cached || caches.match(OFFLINE_URL));
        })
    );
  }
});
```

### 登録（ui.js）

```javascript
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((reg) => console.log('SW registered:', reg.scope))
      .catch((err) => console.error('SW registration failed:', err));
  });
}
```

### 注意点: キャッシュ更新

スタイルや JavaScript を更新しても、Service Worker のキャッシュが古いバージョンを返す場合があります。開発時は DevTools → Application → Service Workers で「Update on reload」を有効にしてください。

## PWA: Web App Manifest

### manifest.json

```json
{
  "name": "Studio344",
  "short_name": "Studio344",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#030303",
  "theme_color": "#a78bfa",
  "icons": [
    {
      "src": "/assets/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/assets/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### HTML への組み込み

```html
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#a78bfa">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
```

### PWA の効果

- ホーム画面への追加（Add to Home Screen）
- スプラッシュスクリーン表示
- アドレスバーなしの全画面表示（`display: standalone`）
- テーマカラーによるブラウザ UI のカスタマイズ

## RSS フィード: feed.xml

### なぜ RSS か

RSS はブログ更新を自動的に購読者に通知する仕組みです。Feedly などのリーダーアプリや、GitHub Actions から連携できます。

### 実装

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Studio344 Blog</title>
    <link>https://studio344.net/blog.html</link>
    <description>Web開発の技術ブログ</description>
    <language>ja</language>
    <atom:link href="https://studio344.net/feed.xml" rel="self" type="application/rss+xml"/>
    <item>
      <title>記事タイトル</title>
      <link>https://studio344.net/blog.html#post/slug</link>
      <pubDate>Mon, 10 Feb 2026 00:00:00 +0900</pubDate>
      <description>記事の要約</description>
    </item>
  </channel>
</rss>
```

### HTML への Auto-Discovery

```html
<link rel="alternate" type="application/rss+xml" title="Studio344 Blog" href="/feed.xml">
```

これにより、ブラウザやリーダーアプリが自動的に RSS フィードを検出できます。

### RSS 自動生成スクリプト

`list.json` から `feed.xml` を自動生成するスクリプトも作成しました:

```javascript
// scripts/generate-rss.js
const posts = require('../assets/posts/list.json');
const rssItems = posts.map(post => `
  <item>
    <title>${post.id}</title>
    <link>https://studio344.net/blog.html#post/${post.id}</link>
    <pubDate>${new Date(post.date.replace(/\./g, '-')).toUTCString()}</pubDate>
  </item>
`).join('');
```

## 3つの技術の連携

```
ユーザーがサイトにアクセス
  ↓
Service Worker がリクエストをインターセプト
  ↓ (ネットワーク成功)
最新コンテンツを表示 + キャッシュ保存
  ↓ (ネットワーク失敗)
キャッシュから表示 or オフラインページ

PWA として
  ↓
ホーム画面からアプリとして起動
  ↓
Service Worker がオフラインでもコンテンツ提供

RSS フィード
  ↓
購読者に新記事を自動通知
  ↓
記事追加時に feed.xml を更新（手動 or スクリプト）
```

## Vanilla JS での実装のメリット

フレームワーク（Next.js, Gatsby など）を使えば PWA や RSS は自動的に設定されますが、Vanilla JS で自前実装することで以下を得られます:

- **完全な制御**: キャッシュ戦略を用途に合わせて微調整できる
- **依存ゼロ**: ビルドツール不要、`sw.js` を置くだけ
- **学習効果**: Web API の仕組みを深く理解できる
- **軽量**: 余計なランタイムや抽象化レイヤーがない

## まとめ

PWA・Service Worker・RSS は、静的サイトを「発見しやすく」「使いやすく」「オフラインでも動く」ようにする3つの柱です。GitHub Pages + Vanilla JS の構成でも十分に実装可能で、ユーザー体験とアクセシビリティの両方を向上させます。
