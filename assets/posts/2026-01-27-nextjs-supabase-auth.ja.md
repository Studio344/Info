# Next.js + Supabase + Fitbit OAuthで認証基盤を構築した話

## はじめに

UCFitnessの開発において、最初に取り組んだ重要な機能が **ユーザー認証** です。Fitbitアカウントでログインし、ウェアラブルデバイスのデータにアクセスするためには、OAuth 2.0による認証フローを正しく実装する必要があります。

この記事では、**Next.js（App Router）** と **Supabase Auth** を組み合わせてFitbit OAuth認証を実装した方法と、その過程で得た知見を共有します。

## 認証フローの全体像

UCFitnessの認証フローは以下のステップで構成されています。

1. ユーザーが「Fitbitでログイン」ボタンをクリック
2. Fitbitの認証ページにリダイレクト（OAuth 2.0 Authorization Code Grant）
3. ユーザーがFitbitアカウントで許可を与える
4. コールバックURLに認証コードが返される
5. サーバーサイドで認証コードをアクセストークンに交換
6. Supabase Authにユーザー情報を保存
7. セッションが確立され、アプリにリダイレクト

## Supabase Authの活用

### なぜSupabase Authを使ったのか

Supabase Authは **Row Level Security（RLS）** と密接に統合されており、認証情報に基づいたデータベースアクセス制御を宣言的に記述できます。これにより：

- ユーザーが自分のデータのみアクセスできるポリシーを簡潔に定義
- サーバーサイドでの認証チェックを最小限に抑えられる
- JWTトークンの管理をSupabaseに委譲できる

### カスタムOAuthプロバイダーの実装

SupabaseにはFitbit用のビルトインプロバイダーがないため、**カスタムOAuthフロー** を構築しました。具体的には：

1. **Next.js API Routeで認証エンドポイントを作成**
   - `/api/auth/fitbit` — Fitbit認証ページへのリダイレクトURLを生成
   - `/api/auth/callback` — コールバック処理とトークン交換

2. **トークンの安全な管理**
   - アクセストークンとリフレッシュトークンはSupabaseの `user_metadata` に暗号化して保存
   - トークンの有効期限を監視し、自動的にリフレッシュ

3. **セッション管理**
   - Supabase Authのセッション機能を活用し、クライアントサイドでの認証状態管理を統一

## 実装で苦労したポイント

### PKCE（Proof Key for Code Exchange）への対応

Fitbit APIはOAuth 2.0のセキュリティ拡張である **PKCE** をサポートしており、これを正しく実装する必要がありました。PKCEでは：

- 認証リクエスト時に `code_verifier` と `code_challenge` を生成
- コールバック時に `code_verifier` を送信して検証

セッションをまたいで `code_verifier` を安全に保持するために、HTTPOnly Cookieを使用しました。

### トークンリフレッシュの自動化

Fitbitのアクセストークンは **8時間** で有効期限が切れます。ユーザーが毎回再ログインするのは現実的ではないため、**リフレッシュトークン** による自動更新を実装しました。

Next.jsのMiddlewareを活用して、APIリクエストの前にトークンの有効性をチェックし、期限切れの場合は自動的にリフレッシュする仕組みです。

### スコープ管理

Fitbit APIでは、アクセスするデータの種類ごとに **スコープ** を指定する必要があります。UCFitnessでは以下のスコープをリクエストしています：

- `activity` — 歩数、消費カロリー
- `heartrate` — 心拍数データ
- `profile` — ユーザープロフィール情報
- `sleep` — 睡眠データ（将来の機能拡張用）

必要最小限のスコープに絞ることで、ユーザーに対する権限リクエストを最小化し、信頼性を確保しています。

## セキュリティ上の考慮事項

認証基盤の構築では、セキュリティを最優先としました。

- **環境変数の管理**: すべてのシークレット（Client ID、Client Secret）は環境変数経由で管理し、コードに直接記述しない
- **CSRF対策**: `state` パラメータを使用して、クロスサイトリクエストフォージェリを防止
- **トークンの暗号化**: デーtabase内のトークンは暗号化して保存
- **HTTPS必須**: すべての認証通信はHTTPS経由で行う

## まとめ

Next.js + Supabase + Fitbit OAuthの組み合わせは、個人プロジェクトにおいて十分に実用的な認証基盤を構築できる選択肢です。特にSupabase AuthのRLS連携は、認可ロジックをデータベースレイヤーに集約できるため、アプリケーションコードをシンプルに保つことができます。

一方で、カスタムOAuthプロバイダーの実装にはPKCEやトークン管理など、セキュリティに関する深い理解が求められます。公式ドキュメントを熟読し、テストを十分に行うことを強くお勧めします。
