# PWA, Service Worker, and RSS — Evolving a Static Site Into an App-Like Experience

I added PWA (Progressive Web App), Service Worker, and RSS feed capabilities to my portfolio site. Even with a framework-free Vanilla HTML/CSS/JS stack, these features can be implemented from scratch. This article covers the implementation details and design decisions.

## Service Worker: Network-First Caching Strategy

### Why Service Worker?

A Service Worker sits between the browser and the network, acting as a proxy. It enables offline support, cache control, and background sync.

### Why Network-First?

Several caching strategies exist:

| Strategy | Behavior | Best For |
|----------|----------|----------|
| Cache-First | Cache priority, fallback to network | Rarely changing static resources |
| Network-First | Network priority, fallback to cache | Frequently updated content |
| Stale-While-Revalidate | Serve cache immediately + update in background | Balanced approach |

Since blog posts and project information update frequently, I chose **Network-First**.

### Implementation (sw.js)

```javascript
const CACHE_NAME = 'studio344-v1';
const OFFLINE_URL = '/404.html';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([OFFLINE_URL]);
    })
  );
  self.skipWaiting();
});

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Network success → cache and return
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
          return response;
        })
        .catch(() => {
          // Network failure → serve from cache
          return caches.match(event.request)
            .then((cached) => cached || caches.match(OFFLINE_URL));
        })
    );
  }
});
```

### Registration (ui.js)

```javascript
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((reg) => console.log('SW registered:', reg.scope))
      .catch((err) => console.error('SW registration failed:', err));
  });
}
```

### Caveat: Cache Updates

After updating styles or JavaScript, the Service Worker cache may serve stale versions. During development, enable "Update on reload" in DevTools → Application → Service Workers.

## PWA: Web App Manifest

### manifest.json

```json
{
  "name": "Studio344",
  "short_name": "Studio344",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#030303",
  "theme_color": "#a78bfa",
  "icons": [
    {
      "src": "/assets/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/assets/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### HTML Integration

```html
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#a78bfa">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
```

### PWA Benefits

- Add to Home Screen capability
- Splash screen on launch
- Full-screen experience without address bar (`display: standalone`)
- Browser UI customization via theme color

## RSS Feed: feed.xml

### Why RSS?

RSS automatically notifies subscribers of new blog posts. It integrates with reader apps like Feedly and can be consumed by GitHub Actions.

### Implementation

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Studio344 Blog</title>
    <link>https://studio344.net/blog.html</link>
    <description>Web development tech blog</description>
    <language>en</language>
    <atom:link href="https://studio344.net/feed.xml" rel="self" type="application/rss+xml"/>
    <item>
      <title>Article Title</title>
      <link>https://studio344.net/blog.html#post/slug</link>
      <pubDate>Mon, 10 Feb 2026 00:00:00 +0900</pubDate>
      <description>Article summary</description>
    </item>
  </channel>
</rss>
```

### HTML Auto-Discovery

```html
<link rel="alternate" type="application/rss+xml" title="Studio344 Blog" href="/feed.xml">
```

This allows browsers and reader apps to automatically detect the RSS feed.

### RSS Generation Script

I also created a script to auto-generate `feed.xml` from `list.json`:

```javascript
// scripts/generate-rss.js
const posts = require('../assets/posts/list.json');
const rssItems = posts.map(post => `
  <item>
    <title>${post.id}</title>
    <link>https://studio344.net/blog.html#post/${post.id}</link>
    <pubDate>${new Date(post.date.replace(/\./g, '-')).toUTCString()}</pubDate>
  </item>
`).join('');
```

## How the Three Technologies Work Together

```
User visits the site
  ↓
Service Worker intercepts the request
  ↓ (Network success)
Display latest content + save to cache
  ↓ (Network failure)
Serve from cache or show offline page

As a PWA
  ↓
Launch as app from home screen
  ↓
Service Worker provides content even offline

RSS Feed
  ↓
Automatically notify subscribers of new articles
  ↓
Update feed.xml when articles are added (manual or scripted)
```

## Benefits of Vanilla JS Implementation

Frameworks like Next.js or Gatsby configure PWA and RSS automatically, but implementing them in Vanilla JS offers:

- **Full control**: Fine-tune caching strategies to your exact needs
- **Zero dependencies**: No build tools required, just drop in `sw.js`
- **Learning value**: Deep understanding of Web APIs
- **Lightweight**: No runtime overhead or abstraction layers

## Conclusion

PWA, Service Worker, and RSS are three pillars that make static sites more discoverable, usable, and resilient offline. They're fully implementable with GitHub Pages + Vanilla JS, improving both user experience and accessibility.
